@startuml
title DFN 


package FractureLibrary <<Folder>>
{


struct FractureStruct{
+ NumeroFratture : unsigned int
+ IdFratture : std::vector<unsigned int>
+ NumeroVertici : std::vector<unsigned int>
+ CoordinateVertici : std::vector<Eigen::MatrixXd>
+ NumeroTracceN : std::vector<std::list<unsigned int>>
+ NumeroTracceP : std::vector<std::list<unsigned int>>
+ NormaleFrattura : std::vector<Eigen::Vector3d> 


####
+ Polygon(VerticesCoordinates, listVertices)
+ void GedimInterface(vector<vector<unsigned int>>& triangles,
                        \t \t \t  \t \t VectorXi& materials)
+ vector<double> computePolygonsArea()
+ vector<vector<vector<unsigned int>>> TriangulatePolygons()
.. Non member function ..
bool ImportaDati(const string& NomeFile, FractureStruct& Fract)

}


struct TracesStruct{
+ ct : unsigned int
+ IdTracce : std::vector<unsigned int>
+ EstremiTracce : std::vector<Eigen::Matrix<double,2,3>>
+ LunghezzaTracce : std::vector<double>
+ PNP : std::vector<Eigen::Matrix<unsigned int,2,2>> 
}


struct PolygonalMesh{
+ NumberCell0D : unsigned int
+ Cell0DId : std::vector<unsigned int>
+ Cell0DCoordinates : std::vector<Eigen::Vector3d>
+ NumberCell1D : unsigned int
+ Cell1DId : std::vector<unsigned int>
+ Cell1DVertices : std::vector<Eigen::Vector2i>
+ NumberCell2D : unsigned int
+ NumeroDiVertici : std::vector<unsigned int>
+ NumeroDiLati : std::vector<unsigned int>
+ Cell2DVertices : std::vector<Eigen::VectorXi>
+ Cell2DEdges : std::vector<Eigen::VectorXi>
}





package Utils <<Folder>>{

abstract Funzione {
+ bool ImportData(const string& fileName, FractureStruct& fract)
}

FractureStruct - Funzione : costruisce <
abstract Funzioni {
+ bool ImportData(const string& fileName, FractureStruct& fract)
+ Matrix<double,2,3> IntersectionLine(Vector4d& plane1, Vector4d& plane2)
+ Vector4d FracturePlane(FractureStruct& fract, const unsigned int& n)
+ bool CheckTraccia(FractureStruct& fract, TracesStruct& trac, const MatrixXd& intersectionLine, const unsigned int& n1, const unsigned int& n2, const double& tol);
+ bool checkIntersezione( FractureStruct& fract, TracesStruct& trac, const unsigned int& n1, const  unsigned int& n2, const double& tol);
+ bool BBoxIntersection(const FractureStruct& fract, const unsigned int& n1, const unsigned int& n2,const double& tol)
+ Matrix<double,2,3> ComputeBoundingBox(const FractureStruct& fract, unsigned int n, const double& tol)
+ bool GeneralOutput(const TracesStruct& trac, const FractureStruct& frac);
+ bool parallelPlanes(Vector4d& plane1, Vector4d& plane2, const double& tol);
+ bool OutputFractures(const TracesStruct& trac, const FractureStruct& frac);
+ bool OutputTraces(const TracesStruct& trac);
+ void descendingOrder(TracesStruct& trac, list<unsigned int>& list, const unsigned int& num, const double& tol);
+ bool subPolygons(list<Vector3d> verticiPolygons, const vector<Matrix<double, 2,3>>& coordEstremiTracce, list<MatrixXd>& sp, const Vector3d& normale,  const double& tol);

}



}

}


package Gedim <<Frame>>
{

}


' PlotPolygon relies upon Gedim
Polygon::GedimInterface --right--> Gedim

' Add notes and link it with an object thourgh the sumbol ..
note "This is an external package" as GedimNote
GedimNote .. Gedim
@enduml